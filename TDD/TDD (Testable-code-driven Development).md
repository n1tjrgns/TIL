# TDD (Testable-code-driven Development)

OKKYCON:2018 TDD

https://www.samsungsds.com/global/ko/support/insights/OKKYCON-TDD.html



정진욱님

http://jwchung.github.io/testing-oh-my

TDD에 관해 윗 분들의 글을 참조해 작성함.



1. TDD가 어려운 이유 - 테스트 대상 코드가 테스트하기 힘들게 디자인 되었기 때문에.

   - DB를 사용하는 경우 테스트하기가 어렵다 -> DB에 테스트 데이터를 설정해야 하기 때문에

     -> 개선이 필요함 

      1. 테스트하기 쉬운 코드와 어려운 코드를 분리 -> 함수를 분리하는 방법으로

         (물론 판단할 수 있는 정도는 개인적 역량의 한계)

      2. Postman 같은 플러그인을 활용해 하기도 함

   - TDD에 대한 오해 : 테스트에 어려움을 느끼는 초심자의 큰 오해 중 하나는, 그 어려움이 테스트 스킬 부족 때문이라고 생각하는 것

     테스트 스킬이 중요하지 않은 것은 아니지만, 그보다 SUT가 얼마나 테스트하기 쉽게 디자인되었는지가 더 중요한 요소

     Toy 프로젝트로 연습을 하며 익숙해지면 레거시 프로젝트에 적용해보는 방식을 추천.



**테스트가 디자인을 이끄는 것이 아니라 좋은 디자인이 테스트하기 쉬운 코드를 만든다**



2. 접근 방식의 변화 - TDD로 할 수 있는 것과 TDD로 할 수 없는 것으로 나누어 접근
   - 이를 분리하기 위해 "높은 응집도와 낮은 결합도"의 설계 기법의 도입이 필요.



3. TDD의 한계점 - 테스트 케이스 작성 시, 구현에 의존적으로 작성되어 불필요한 수정이 빈번해질 수 있음
   - 대안으로 업무 시나리오에 맞추어 작성하는 BDD(Behavior-Driven Development)를 적용하면 완화 될 수 있음.



1-1. 불확실성

- 테스트가 가능하려면 입력 값에 항상 같은 결과를 반환해야 한다.

  아래 메소드는 현재 시각에 따라 "AM" or "PM"을 반환한다. 실행되는 시각에 따라 결과가 좌지우지 되므로 결과 값에 확신을 가질 수 없다. -> 즉 테스트가 불가능하다.

  불확실성은 테스트를 어렵게 만드는 첫번째 요인이다. (ex : 랜덤 수, 임의시각)

```
public string GetAMOrPM()
 {
     var now = DateTime.Now;
     if (now.Hour < 12)
     {
         return "AM";
     }
     else
     {
         return "PM";
     }
 }
```









testdouble (테스트 대역) ex. Mock

- 서버 B의 응답을 무조건 받았다는 가정하에, 서버 A의 로직만 테스트



오버엔지니어링 방지