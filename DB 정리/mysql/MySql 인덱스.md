## MySql 인덱스

#### 인덱스 생성의 목적

- select query의 성능 향상



#### 인덱스는 B-Tree 구조

- 인덱스 탐색은 Root -> Branch -> Leaf의 디스크 저장소 순으로 진행

- 디스크를 읽는 작업 : 성능 저하 원인

  - 디스크 저장소에 얼마나 덜 접근하게 하는지, Root에서 Leaf까지 오고가는 횟수를 줄이자.

- 갯수는 3~4개가 적당하다.

  - 인덱스 또한 공간을 차지하기 때문에, 많을수록 많은 공간을 차지한다.

  - 많은 인덱스로 옵티마이저가 잘못된 인덱스를 선택할 수도 있다.

    

#### 인덱스 키 값의 크기

InnoDB (MySql)은 `디스크에 데이터를 저장하는 기본 단위`를 `페이지` 단위로 관리한다.

`페이지는 16KB`로 크기가 고정되어있다.


인덱스의 크기가 16 Byte이고, 자식노드의 주소 크기가 12 Byte이면

`16*1024 / (16+12) = 585 ` 로 하나의 페이지에 585개가 저장된다.



읽어야하는 row가 많아져서 여러 페이지를 읽어야한다면 성능 저하가 발생하게된다.



#### 인덱스 컬럼 기준

1개의 컬럼에만 인덱스를 걸어야 하는 경우, `카디널리티(Cardinality)`가 가장 높은 것을 잡아야한다.

> 카디널리티(Cardinality)
>
> 해당 컬럼의 **중복된 수치**를 나타냄.
>
> ex : 성별, 학년 -> 카디널리티가 낮다.
>
> ​		주민번호, 계좌번호 -> 카디널리티가 높다.



그 이유는 인덱스로 최대한 효율을 뽑아내기 위해서, 해당 인덱스로 많은 부분을 걸러내야 하기 때문이다.



#### 여러 컬럼으로 인덱스 구성시 기준

- 카디널리티가 `높은순에서 낮은순`으로 구성



#### 인덱스를 타지 않는 쿼리

- 여러 컬럼으로 인덱스가 구성되어 있을 때, `최소 첫 번째 인덱스 조건은 조회조건에 포함`되어야 한다.

그렇지 않으면 인덱스를 타지 않는다.



- `between`, `like`, `<`, `>` 등 범위 조건은 해당 컬럼 인덱스를 타지만, 그 귀 인덱스 컬럼은 인덱스가 사용되지 않는다.



- 컬럼명을 그대로 사용해야한다.
  - `where salary * 10 > 15000` 은 인덱스를 타지못한다.
  - where salary > 1500 * 10 은 탈 수 있다.



- null 값의 경우 is null 조건으로 인덱스 레인지 스캔이 가능하다.



**참고**

 https://jojoldu.tistory.com/243 