## DB Index

인덱스는 특정 데이터를 검색하기 위해 테이블 레코드를 full scan하지 않고, 인덱스가 적용된 컬럼의 테이블을 파일로 저장해놓고 그것을 검색해 효율을 높이기 위해 사용한다.

(컬럼, 인덱스 주소)의 key, value 구조로 구성되어있다.



#### 인덱스는 Range Scan 을 한다.

또한 인덱스는 키, 컬럼순으로 정렬되어있기 때문에 특정값을 찾다가 해당 범위를 넘어서면 멈춘다.



#### 인덱스에 가장 많이 사용되는 구조 B-tree

Root, Branch, Leaf로 구성되어있고, 맨 아래 **Leaf의 깊이는 모두 동일**하다.

![image-20210224162214137](../AppData/Roaming/Typora/typora-user-images/image-20210224162214137.png)



ex) between 10 and 20 조건이 있을때

10을 기준으로 찾은 후 해당 노드에서 값을 찾고(13,17...) , 없다면 부모 노드로 올라가서 20을 검사한다.

20보다 큰 값이 있다면 B-tree가 정렬된 상태로 유지되기 때문에 더 이상 탐색을 할 필요가 없다. 



#### B-tree 인덱스 탐색과정

찾으려는 값이 branch block에서 가장 왼쪽 값보다  작거나 같으면 왼쪽 포인터, 사이에 있으면 사이 포인터, 가장 큰 값보다 크면 오른쪽 포인터로 찾아간다.

이 과정에서 leaf block을 찾고 그 안에서 찾고자 하는 값이 있으면 성공이고 없으면 실패한다.



#### 인덱스는 언제 적용해야할까?

인덱스는 select 문의 where, join성능을 향상시키기 위해 사용한다.

insert, update, delete에서는 성능이 떨어진다



#### 왜??

- insert시 해당 테이블뿐만 아니라, 인덱스 테이블에도 생성을 해줘야 한다.

  만약, 인덱스 테이블의 leaf block이 꽉찼는데 사이에 값이 들어오면 정렬되어있는 block을 이동시켜야하고, 이동시키는 과정이 redo에 기록되는 수고가 생긴다.

- delete는 레코드가 삭제하고 그 공간을 다른 레코드가 사용할 수 있지만, 인덱스 테이블은 사용 안함 표시만 하고 해당 공간은 계속 차지하고 있기 때문에 주의해야한다.

- update는 delete하고 insert하는식의 방식이라 2가지 쿼리가 동시에 작용해 부하가 많아진다.



#### 결론

- **검색(select)이 많고, insert, update, delete가 적게 일어나는 테이블**에서 사용하면 좋다.



#### 인덱스를 타지 않는 경우

1. 칼럼명에 함수, 수식(연산자) 사용하는 경우
2. Like 연산자 사용시 문자 앞에 % 있는경우











https://jeong-pro.tistory.com/114