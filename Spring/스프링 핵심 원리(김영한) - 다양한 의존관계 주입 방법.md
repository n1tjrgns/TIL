## 스프링 핵심 원리(김영한) - 다양한 의존관계 주입 방법

----

#### 의존관계 주입 4가지 방법

- 생성자 주입
- 수정자 주입(setter 주입)
- 필드 주입
- 일반 메서드 주입



#### 생성자 주입을 선택해라!

- 생성자를 통해서 의존 관계를 주입 받는다.

특징

- 생성자 호출시점 딱 1번만 호출되는 것이 보장된다.
- `불변, 필수` 의존관계에 사용 (final 키워드 가능)



불변

- 의존관계 주입은 한번 주입되면 어플리케이션 종료시점까지 의존관계를 변경할 일이 없다.
  - 대부분의 의존관계는 어플리케이션 종료 전까지 변하면 안된다.(불변)
- 객체를 생성할 때 딱 1번만 호출되므로 불변하게 설계할 수 있다.



> 생성자 주입 방식을 선택하는 이유?
>
> - 프레임워크에 의존하지 않고, 순수한 자바 언어의 특징을 잘 살리는 방법
> - 기본으로 생성자 주입을 사용하고 필수 값이 아닌 경우 수정자 주입 방식을 옵션으로 부여한다.



----

#### @Autowired, @Quailifier, @Primary

- 빈이 여러개 있을때 찾는 순서



#### @Primary

- 동일한 빈이 여러개 있을 때 찾는 우선 순위를 부여해준다.



@Quailifier를 사용할 경우 모든 코드에 해당 어노테이션을 붙여줘야한다.

> 따라서 코드에서 자주 사용하는 메인 데이터베이스의 커넥션을 획득하는 스프링 빈에는 @Primary를 적용하고,
>
> 서브 데이터베이스 커넥션 빈은 @Qualifier를 지정하는 것이 좋다.



@Primary는 기본값처럼 동작하는 것이고, @Quailifier는 매우 상세하게 동작한다.

스프링은 자동보다는 수동이 넓은 범위의 선택권 보다는 좁은 범위의 선택권이 우선순위가 높다. 따라서 @Qualifier가 우선순위가 높다.



Quailifier의 문자열은 컴파일 시점에는 확인이 되지 않는다.

런타임 시점에만 에러가 발생하기 때문에, 별도의 어노테이션을 구현하여 사용하면 컴파일 시점에 에러를 잡을 수 있다.

```java

@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Qualifier("mainDiscountPolicy")
public @Interface MainDiscountPolicy {

}
```

- 기존의 Qualifier 어노테이션 선언부를 우리가 새로 작성한 @MainDiscountPolicy로 대체해주면 된다.



----

#### 자동, 수동 올바른 실무 운영 기준

편리한 자동 기능은 기본으로 사용하자.

- @Controller, @Service 등등
- 매번 @Configuration 설정에서 @Bean으로 관리하기 번거롭다.



수동 빈 등록은 언제 사용할까?

업무로직, 기술지원 로직으로 나눠 등록한다.

**업무로직** : 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 리포지토리 등등

**기술지원** : 기술적인 문제나 공통 관심사(AOP) 등을 처리할 때, 주로 디비 연결이나, 공통 로그처리

