## [Spring] 스프링 웹 플럭스(Spring Web Flux)

최신 기술들의 특장점 정도는 알고 있는것이 좋다라는 얘기를 들은적이 있다.

그래서 웹 플럭스에 대해 알아보려고 한다.



----



#### 대표적인 특징

- 스프링 5.0 버전 이후 추가
- 완전한 Non Blocking I/O으로 리액티브 스트림 지원



#### 탄생배경

적은 수의 쓰레드와 적은 하드웨어 자원으로 `동시성`을 처리하기 위해 Non Blocking 웹 스택이 필요해졌다.

서블릿 3.1은 Non Blocking I/O를 위한 API를 제공했지만, 이를 사용할시 Filter, Servlet과 같은 `Synchronous`식과 (getParameter, getPart)등의 `Blocking` 방식의 다른 서블릿 API와 어울리지 못한다.

이로인해 Non Blocking 실행환경에서 충분한 역할을 하기 위한 공통 API가 탄생한다.

Non Blocking이 잘 확립된 Netty 같은 서버 때문에 중요하다.



또 다른 배경은 `함수형 프로그래밍` 이다.

자바 8에서 추가된 람다식은 비동기 로직을 서술적으로 작성할 수 있게 해주는 Non Blocking 어플리케이션과 연속형 API(`CompletableFuture, ReactiveX`)에 도움이 된다.

자바 8은 스프링 웹 플럭스가 어노테이션 컨트롤러와 함수형 웹 엔드포인트를 사용할 수 있게 만들었다.



#### 리액티브 프로그래밍(Reactive Programming)

`리액티브(reactive)`는 I/O 이벤트에 반응하는 네트워크 요소, 마우스 이벤트에 반응하는 UI 컨트롤러처럼 `변화에 반응하는 것을 중점`으로 둔 프로그래밍 모델을 말한다.

그런 의미에서 Non Blocking은 Blocking 되지 않고 작업이 완료되거나, 데이터가 사용 가능해지는 시점에 반응하기 때문에 `리액티브`라고 할 수 있다.

Non Blocking 코드에서는 생산자가 소비자를 압도하지 않도록 `이벤트의 속도를 제어하는 것`이 중요하다.



리액티브 스트림은 백프래셔(Synchronous, 명령형 코드, 블로킹 호출)를 통해 `비동기 컴포넌트 사이의 상호 작용을 정의`하는 작은 스펙이다.(자바 9에서 적용됨)

예를 들어, 데이터 저장소는 HTTP 서버가 응답에 사용할 수 있는 데이터를 생성할 수 있다. 리액티브 스트림의 목적은 구독자를 통해 발행자가 데이터를 얼마나 빠르게 or 느리게 생산할지 제어하도록 하는 것이다.

> 발행자가 속도를 늦출 수 없다면?
>
> 리액티브 스트림의 목적은 오직 매커니즘의 경계 설정이다.
>
> 발행자가 속도를 늦출 수 없는 경우에는 버퍼 사용, 버림(drop) 또는 실패(fail)를 결정해야 한다.



#### 리액티브 API

리액티브 스트림은 시스템 상호 정보 교환에 있어 중요한 역할을 한다.

하지만 어플리케이션 API에는 상대적으로 유용하지 못하다(너무 low level이다).

어플리케이션은 비동기 로직을 작성하기 위해 보다 고수준, 풍부한 함수형 API를 필요로 한다.

자바 8의 스트림 API와 유사하지만 컬렉션에 국한되지 않는다.



`Reactor	`는 스프링 웹 플럭스가 채택한 리액티브 라이브러리다.

리액터는 ReavtiveX와 함께하는 풍부한 연산자를 통해 `Mono, Flux` 방식 API를 제공한다.

리액티브 스트림의 라이브러리이기 때문에 리액터의 연산자는 Non Blocking, 백 프레셔를 지원하며, 특히 서버 사이드 자바에 집중한다. 



웹 플럭스는 리액터에 핵심적인 의존성을 가지지만, 리액티브 스트림을 통해 다른 리액티브 라이브러리들과 상호 운용이 가능하다.

일반적으로 웹 플럭스 API는 Plain Publisher를 인풋으로 받고, 내부적으로 이를 리액터 타입으로 맞춰 적용하고, 사용한 후 Flux or Mono를 아웃풋으로 반환한다.

어떠한 Publisher든 인풋으로 전달해 아웃풋에 대한 연산을 적용할 수 있지만, 또 다른 리액티브 라이브러리 사용을 위해서는 아웃풋 형식을 맞춰줘야만 한다.

언제든지 필요에 따라 RxJava 또는 다른 리액티브 라이브러리에 쉽게 적용될 수 있다.



#### 프로그래밍 모델

spring web module은 리액티브 기반을 포함하며, HTTP 추상화, 리액티브 스트림 어댑터, 코덱, 그리고 서블릿 API와 유사하면서 Non Blocking을 포함하는 핵심 `WebHandler API`를 포함한다.

- **어노테이티드 컨트롤러** 

  스프링 MVC와 일치, spring-web 모듈과 동일한 어노테이션을 기반으로 구성.

  리액티브(리액터, RxJava) 반환 타입을 지원하나 둘을 구분짓기 어려움.

  스프링 웹 플럭스는 리액티브 @RequestBody argument를 지원

  

- **함수형 엔드포인트**

  람다 기반의 경량 함수형 프로그래밍 모델

  요청을 라우팅하고 핸들링하기 위해 어플리케이션이 사용할 수 있는 유틸리티의 모음

  어노테이티드 컨트롤러와의 차이점  

  - 어플리케이션의 요청 핸들링을 시작부터 끝까지 책임지냐 vs 어노테이션을 통해 의사를 표시하고 콜백을 받느냐



