## Garbage Collection 튜닝

이 글을 보기전에 JVM의 GC에 대해 알아야 한다.

필요한 경우 따로 정리한 글을 참고하길 바란다.





#### GC 튜닝을 꼭 해야 하는가 ??

모든 Java 기반 서비스에서 GC 튜닝을 해야 할까??

- 그렇지 않다.

모든 서비스에서 해야한다면 GC 튜닝 전문가가 생기지 않았을까 하는 개인적인 생각이다.



GC 튜닝이  필요 없다는 것은 운영 중인 Java 기반 시스템의 옵션과 동작이 아래와 같다는 것이다.

- -Xms 옵션과 -Xmx 옵션으로 메모리 크기를 지정했다.
- -server 옵션이 포함되어있다.
- 시스템에 Timeout 로그와같은 로그가 남지 않는다.



위와 반대로 메모미 크기를 지정하지 않고, Timeout 로그가 수도 없이 출력되면 GC 튜닝을 하는 것이 좋다.



`GC튜닝은 가장 마지막에 하는 작업이다.`



GC튜닝을 하는 이유가 무엇인지 근본적으로 생각해봐야한다.

Java에서 생성된 객체는 GC가 처리해서 지운다. 생성된 객체가 많으면 많을수록 가비지 컬렉터가 처리해야 하는 대상도 많아지고, GC를 수행하는 횟수도 증가한다.

즉, `우리가 운영하는 시스템의 GC를 적게 하려면 객체 생성을 줄이는 작업을 먼저 해야 한다.`







String 대신 StringBuilder나 StringBuffer를 사용하는 것을 생활화하는 것 부터가 시작이다.

그리고 로그를 최대한 적게 쌓도록 하는 것이 좋다. 하지만 아무리 String을 최대한 사용하지 않고, Log 처리를 잘 하더라도, 10~100 MB 크기의 XML, JSON을 파싱하면 엄청난 임시 메모리를 사용한다. 

XML과 JSON을 사용하지 않을 수는 없으니 이렇다는 것을 알고 넘어가자.



어플리케이션 메모리 사용도 튜닝을 많이 해서 어느 정도 만족할 만한 상황이 되었다면, 본격적으로 GC튜닝을 시작하면 된다.

GC 튜닝의 목적을 두 가지로 보면, Old 영역으로 넘어가는 객체의 수를 최소화하는 것과 Full GC의 실행 시간을 줄이는 것이다.



#### Old 영역으로 넘어가는 객체의 수 최소화하기

JDK 7 부터 본격적으로 사용할 수 있는 G1 GC를 제외한, Oracle JVM에서 제공하는 모든 GC는 Generational GC다. 즉, Eden 영역에서 객체가 처음 만들어지고, Survivor 영역을 오가다가, 끝까지 남아 있는 객체는 Old 영역으로 이동한다.

간혹 Eden 영역에서 만들어지다가 크기가 커져서 Old 영역으로 바로 넘어가는 객체도 있긴 하다.

Old 영역의 GC는 New 영역의 GC에 비해 상대적으로 시간이 오래 소요되기 때문에 Old 영역으로 이동하는 객체의 수를 줄이면 Full GC가 발생하는 빈도를 많이 줄일 수 있다.

Old  영역으로 넘어가는 객체의 수를 줄인다는 말은, New 영역의 크기를 잘 조절해 큰 효과를 볼 수 있다는 것이다.



#### Full GC 시간 줄이기

Full GC의 실행 시간은 상대적으로 Minor GC에 비해 길다.

그래서 Full GC 실행 시간이 오래 소요되면(1초 이상) 연계된 여러 부분에서 타임아웃이 발생할 수 있다.  그렇다고 Full GC 실행 시간을 줄이기 위해서 Old 영역의 크기를 줄이면 자칫 OutOfMemoryError가 발생하거나 Full GC 횟수가 늘어난다.

반대로 Old 영역의 크기를 늘리면 Full GC 횟수는 줄어들지만 실행 시간이 늘어난다. `Old 영역의 크기를 적절하게 잘 설정해야한다.`



#### GC의 성능을 결정하는 옵션

GC옵션은 남이 설정한 옵션이 성능이 잘 나왔다고해서 따라하면 안된다.

그 이유는 위에서도 언급했듯이 서비스마다 생성되는 객체의 크기도 다르고 생성-소멸 기간도 다르기 때문이다.



옵션을 많이 설정한다고 시스템의 GC 수행 속도가 빨라지지 않는다. 오히려 더 느려질 확률이 높다.

`두 대 이상의 서버에 GC 옵션을 다르게 적용해서 비교해 보고, 옵션을 추가한 서버의 성능이나 GC 시간이 개선되었을 때에만 옵션을 추가하는 것이 GC 튜닝의 기본 원칙이다.`



- ##### 튜닝 시 기본적으로 확인해야 하는 JVM 옵션

| 구분               | 옵션              | 설명                             |
| ------------------ | ----------------- | -------------------------------- |
| 힙(heap) 영역 크기 | -Xms              | JVM 시작 시 힙 영역 크기         |
|                    | -Xmx              | 최대 힙 영역 크기                |
| New 영역의 크기    | -XX:NewRatio      | New 영역과 Old 영역의 비율       |
|                    | -XX:NewSize       | New 영역의 크기                  |
|                    | -XX:SurvivorRatio | Eden 영역과 Survivor 영역의 비율 |

GC 튜닝을 할 때 -Xms, -Xmx는 필수 옵션이다. 그리고 NewRatio 옵션을 어떻게 설정하느냐에 따라 GC 성능에 많은 차이가 발생한다.



Perm 영역의 크기는 OutOfMemoryError가 발생하고, 그 문제의 원인이 Perm 영역의 크기 때문일 때만 -XX:PermSize 옵션과 -XX:MaxPermSize 옵션으로 지정해도 큰 문제는 없다.



GC의 성능에 많은 영향을 주는 또 다른 옵션은 GC 방식이다.



- ##### GC 방식에 따라 지정 가능한 옵션

| 구분                   | 옵션                               | 비고 |
| ---------------------- | ---------------------------------- | ---- |
| Serial GC              | -XX:+UserSerialGC                  |      |
| Parallel GC            | -XX:+UserParallelGC                |      |
|                        | -XX:ParallelGCThreads=value        |      |
| Parallel Compacting GC | -XX:+UserParallelOldGC             |      |
| CMS GC                 | -XX:+UseConcMarkSweepGC            |      |
|                        | -XX:+UseParNewGC                   |      |
|                        | -XX:+CMSParallelRemarkEnabled      |      |
|                        | -XX:+UseCMSInitiatingOccupancyOnly |      |
| G1                     | -XX:+UnlockExperimentalVMOptions   |      |
|                        | -XX:+UseG1GC                       |      |



G1 GC를 제외하고는, 각 GC방식의 첫 번째 줄에 있는 옵션을 지정하면 CG 방식이 변경된다. GC 방식 중에서 특별히 신경 쓸 필요가 없는 방식은 Serial GC다. Serial GC는 클라이언트 장비에 최적화되어 있기 때문이다.



#### GC 튜닝의 절차

GC를 튜닝하는 절차도 대부분의 성능 개선 작업과 크게 다르지 않다.

1. ##### GC 상황 모니터링

   GC 상황을 모니터링하며 현재 운영되는 시스템의 GC 상황을 확인해야 한다.

   

2. ##### 모니터링 결과 분석 후 GC 튜닝 여부 결정

   GC 상황을 확인한 후에는, 결과를 분석하고 GC 튜닝 여부를 결정해야 한다. 분석한 결과를 확인했는데 GC 수행에 소요된 시간이 0.1~0.3초라면 굳이 튜닝을 할 필요는 없다.

   하지만 GC 수행 시간이 1~3초, 심지어 10초가 넘는 상황이라면 GC 튜닝을 진행해야 한다.

   

   그런데, 만약 Java 메모리를 10GB 정도로 할당해서 사용하고 있고 메모리의 크기를 줄일 수 없다면 필자가 GC 튜닝에 대해서 안내해 줄 수 있는 방법이 없다. GC 튜닝 전에 시스템의 메모리를 왜 높게 잡아야 하는지에 생각해 봐야 한다.

   

   만약 메모리를 1GB나 2GB로 지정했을 때, OutOfMemoryError가 발생한다면, 힙 덤프를 떠서 그 원인을 확인하고, 문제점을 제거해야 한다.

   

   힙 덤프는 현재 Java 메모리에 어떤 객체와 어떤 데이터가 있는지 확인하기 위한 메모리의 단면 파일이라고 생각하면 된다.  이 파일은 JDK에 포함되어 있는 jmap 이라는 명령으로 생성할 수 있다. 

   파일을 생성하는 도중에는 Java 프로세스가 멈추기 때문에 시스템을 운영하고 있을 때에는 이 파일을 생성하면 안 된다.

   

3. #####  GC 방식/메모리 크기 지정

   GC 튜닝을 진행하기로 결정했다면 GC 방식을 선정하고 메모리의 크기를 지정한다. 이때 서버가 여러 대면 여러 대의 서버에 GC 옵션을 서로 다르게 지정해서 GC 옵션에 따른 차이를 확인하는 것이 중요하다.

   

4. ##### 결과 분석

   GC 옵션을 지정하고 적어도 24시간 이상 데이터를 수집한 후에 분석을 실시한다. 운이 좋으면 해당 시스템에 가장 적합한 GC 옵션을 찾을 수 있다. 그렇지 않다면 로그를 분석해 메모리가 어떻게 할당되는지 확인해야 한다.

   그 다음 3번의 메모리 크기를 변경해 가며 최적의 옵션을 찾는다.

   

5. ##### 결과가 만족스러울 경우 전체 서버에 반영 및 종료

   GC 튜닝 결과가 만족스러우면 전체 서버의 GC 옵션을 적용하고 마무리 한다.

​		



##### 참고

https://d2.naver.com/helloworld/37111