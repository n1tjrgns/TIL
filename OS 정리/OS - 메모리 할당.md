## OS - 메모리 할당

#### Continuous Memory Allocation - 연속 할당

`연속된 공간의 메모리를 프로세스에게 할당 해주는 방법`

연속적으로 메모리를 할당해주면 프로세스마다 할당된 메모리 공간 사이에 할당되지 않은 `빈 공간`이 생기게 된다. 

이 공간을 `Hole` 이라고 한다. 즉, Hole은 현재 `할당이 가능한 메모리 공간`들을 말한다.



연속된 메모리 공간을 할당해주는 방법에는 `세 가지 방법`이 존재한다.

1. First-Fit : 메모리 요청이 들어왔을 때 요청한 크기를 만족하는 Hole 중 가장 첫 번째 Hole을 할당
2. Best-Fit :                                                                                                       가장 작은 크기의 Hole을 할당
3. Worst-Fit :                                                                                                    가장 큰 크기의 Hole을 할당



할당 크기는 프로세스가 필요로 하는 정확한 크기로도 할당이 가능하지만 그렇지 않은 경우도 많다.

왜냐하면 `메모리를 할당해주는 단위는 Byte가 아니라 시스템의 Block 단위`이기 때문이다.

Block은 시스템마다 크기가 다르다.



예를들어 시스템에서 Block 단위가 1KByte 일 때 프로세스가 9.3KByte를 요청한다면, 블록 단위로 10Block. 

즉, 10KByte를 할당해준다. 이렇게 하면 0.7KByte의 메모리 낭비가 일어난다.



이렇게 Block 단위 할당으로 인해 `요청하는 메모리 크기보다 큰 메모리를 할당해주어 메모리 낭비가 일어나는 것`을 `내부 단편화`라고 한다.



> 그럼 외부 단편화도 있지않을까?



외부 단편화는 메모리 공간을 연속적으로 할당해주기 때문에 발생한다.

![1560832851771](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1560832851771.png)

위 그림 처럼 메모리 공간이 할당 되어 있다고 가정했을 때, 여유 공간은 10 + 10 + 30 = 50이 된다.

하지만 메모리에서 40의 공간을 요청한다면?

> 할당하지 못한다.

여유 공간은 50이지만, 연속된 공간이 40만큼 없기 때문이다.

이처럼 메모리 여유 공간의 크기는 충분하지만 연속되어 있지 않아 할당해주지 못하는 문제를 외부 단편화라고 한다.



#### 외부 단편화 해결 방법

1. Compaction(압축)

할당된 메모리 공간들을 한쪽으로 모아 연속된 공간을 확보한다.

하지만 실행 시간에 주소 바인딩이 일어나는 프로그램들만 가능하며, 그렇지 않으면 압축되었을 때 잘못된 메모리 공간의 주소를 접근할 수 있다. 그렇기 때문에 Compaction 기법은 상당히 제한적이다.



2. Paging

Paging은 프로세스에게 메모리를 연속적으로 할당해주지 않는 방법이다.

>  그렇다면 어떻게 비연속적으로 할당해주지?



프로세스의 Logical Memory를 조각으로 나누어 그에 대응하는 Physical Memory 공간 조각이 어디에 위치하는지 목차와 같은 역할을 하는 Page Table에 저장한다.

`Logical Memory의 조각을 Page`라고 하고, `Physical Memory의 조각을 Frame` 이라고 한다.

여기서 중요한 것은 `Page의 크기와 Frame의 크기가 같고`, `Page Table의 인덱스 수는 Page 수와 같다.`

![1560833647935](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1560833647935.png)



Page Table은 PCB에 저장되며 프로세스가 종료되면 같이 사라진다.



#### Paging Address Translation

가상 주소를 물리 주소로 변환하는 과정을 address translation이라고 한다.

Paging 기법은 메모리의 연속적인 공간에 올라가지 않기 때문에 각각 어느 위치에 올라가는데 Page Table에 저장된 값으로 주소를 변환해 원하는 위치에 접근해야 한다.

Paging 기법을 통해 CPU에서 나온 Logical Address는 다음과 같은 명령어 구조를 가진다.



r 물리주소 = p 프레임 번호 d offset

